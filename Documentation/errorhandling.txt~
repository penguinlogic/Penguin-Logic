The definition file is scanned by the scanner in response to a 'getsymbol()' call from the parser.
Each symbol is identified by the scanner to be one of the symbols defined in 'symbol.h'
That symbol is then instantiated as a symbol object by the scanner, and returned to the parser.

Syntax Errors
Picked up by the scanner and parser.
Errors such as invalid characters which do not conform to any of the allowed symbol types cannot be instantiated as symbol objects, and thus are picked up by the scanner.
Any symbols which are technically valid are passed to the parser which then conducts syntax checking.
Each rule in the EBNF grammar is represented by a function in the parser class.
Each function repeatedly calls 'getsymbol()' on the scanner, and either tests the symbol directly if a terminal symbol is expected (e.g. 'DEVICES', '{', etc.) or if a non-terminal is expected, calls the parser function which tests that non-terminal in a similar fashion.
Errors are dealt with by raising exceptions. Every function in the parser has its own exception class(es) which it can raise to describe the various errors.
Errors are reported in the required way; when an exception is raised, a description of the error, and its location in the definition file is returned, and a running total of errors incremented.
An error occurring anywhere in a 'rule' line causes the rest of that line to be skipped (by finding the terminating semicolon). A rule line is any line defining a device, a connection or a monitor point.
Thus functions which parse smaller components than a rule line simply raise a suitable error which is caught by the rule function, which then advances to the next semicolon before returning.
The only higher level in the grammar than a rule line is the 'section'. A syntax error here means a bad keyword and/or incorrect braces ('{', '}') have been used. The error recovery method here is to ignore that entire section, i.e. advance to the next section keyword.

Error conditions which will be detected:
Bad char: char is not allowed in the definition file (e.g. '@', 'Â£', etc.)
Bad uint: number is out of range (<1, >16, not integer)
Bad uname: uname is not valid (does not start with alphabetic char, is not otherwise alphanumberic)
Expected a '.': the grammar requires a '.' which was not found
Expected a ';': the grammar requires a ';' which was not found
Expected a '=': the grammar requires a '=' which was not found
Expected a '>': the grammar requires a '>' which was not found
Expected a '{': the grammar requires a '{' which was not found
Expected a '}': the grammar requires a '}' which was not found
Expected an uint: the grammar requires a uint which was not found
Expected an bool: the grammar requires a bool which was not found
Expected an inname: the grammar requires an inname which was not found
Expected an outname: the grammar requires an outname which was not found
Expected a device name: the grammar requires a device name ('CLOCK', 'AND', etc.) which was not found
Expected a device switch: the grammar requires an device switch ('numinputs', etc.) which was not found
Expected a device: the grammar requires a device which was not found
Expected a uname: the grammar requires an uname which was not found
Expected keyword 'DEVICES': the grammar requires a keyword 'DEVICES' which was not found
Expected keyword 'CONNECTIONS': the grammar requires a keyword 'CONNECTIONS' which was not found
Expected keyword 'MONITOR': the grammar requires a keyword 'MONITOR' which was not found

Semantic Errors
Picked up by logic in the parser and by calling methods of the network and devices classes.
The following semantic requirements are checked:

Sections in order (DEVICES, CONNECTIONS, MONITOR)
0 or more rules in each section
unames in CONNECTIONS and MONITOR must be defined in DEVICES
each device name must have the correct device switch and quantity (bool or uint or none) associated with it
outname and inname must be valid for specified uname
unames must be unique
in CONNECTIONS, each input must be connected to exactly 1 output
A comment may be enclosed in slashes ('/'), and may run across multiple lines (NB this is filtered by the scanner when extracting symbols)
























