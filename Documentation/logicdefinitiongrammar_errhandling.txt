LogicDefinitionGrammar = { section }
section                = ( 'DEVICES' '{' {devrule} '}' ) |
                         ( 'CONNECTIONS' '{' {connrule} '}' ) |
                         ( 'MONITOR' '{' {monrule} '}' )
/* An error in a 'section' rule will cause an exception which ends parsing of that section.
   Parsing continues at next section keyword.
   If suitable keyword not found: "EXCEPTION: Expected: 'DEVICES', 'CONNECTIONS' or 'MONITOR' keyword"
   If '{' or '}' not found: "EXCEPTION: Expected: '{' or '}'"
   If unexpected characters found: "EXCEPTION: Unexpected characters found"
*/

devrule                = uname '=' device ';'
/* An error in a 'devrule' rule will cause an exception which ends parsing of that devrule.
   Parsing continues after next ';'
   An invalid 'uname' or 'device' should not stop parsing of 'devrule'
   If '=' not found: "EXCEPTION: Expected: '='"
   If ';' not found: "EXCEPTION: Expected: ';'"
   If unexpected characters found: "EXCEPTION: Unexpected characters found"
*/

connrule               = uname [ '.' outname ] ';'
monrule                = uname [ '.' outname ] ';'
/* An error in a 'connrule' or 'monrule' rule will cause an exception which ends parsing of that rule.
   Parsing continues after next ';'
   An invalid 'uname' or 'outname' should not stop parsing of 'devrule'
   If no '.' present, 'outname' will not be detected (and an invalid uname may be found)
   If ';' not found: "EXCEPTION: Expected: ';'"
*/

uname                  = ''' alnumchar { alnumchar } '''
/* An error in parsing 'uname': "EXCEPTION: Invalid uname"
   Parsing continues after next ';'
*/

device                 = ( 'CLOCK' '-period' uint ) |
                         ( 'SWITCH' '-initialvalue' bool ) |
                         ( 'AND' '-numinputs' uint ) |
                         ( 'NAND' '-numinputs' uint ) |
                         ( 'OR' '-numinputs' uint ) |
                         ( 'NOR' '-numinputs' uint ) |
                         ( 'DTYPE' ) |
                         ( 'XOR' )
/* 
*/

outname                = 'Q' | 'QBAR'
inname                 = ( 'I' { uint } ) |
                         'DATA'
                         'SET'
                         'CLEAR'
                         'CLK'
